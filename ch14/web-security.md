## Web安全基础

Web安全是一个很大的领域。可单独拿出来作为Web安全的课程来讲，完整的内容可以写一本几百页的书。技术是不断更新的，软件开发越来越复杂，随之带来的问题也越来越多，并且漏洞也是千奇百怪。

这部分内容选取一些危害比较大，并且比较经典的问题作为主要内容。这些问题是Web开发一直都要考虑的问题。这些问题现在都有比较好的解决方案，但是没有人能保证网站100%不出现问题，因为现在的程序非常复杂，所以安全问题是肯定存在的，只不过有些没有发现，甚至是有些问题开发人员知道但不对外透漏。

#### XSS

XSS的全称是Cross-site Scripting，为区别于CSS，缩写改成XSS。任何允许用户输入的情况都可能存在XSS攻击。XSS攻击通常是这样的形式：用户输入了一段恶意代码，通常是JavaScript，也可以是HTML。后台进程没有处理或者有处理不到的情况，这些数据在页面显示往往会作为代码执行。比如，本来应该是正常的评论输入框，用户输入后，直接在页面渲染显示，如果用户输入 \<img src="https://a.b.com/a.jpg"\>则会显示图片，如果输入\<script\>alert(123);\<\script\>则会显示弹出框，这种情况会在模板渲染中生效，而如果AJAX获取接口数据动态设置DOM是不生效的。

#### XSS实例演示

现在让我们来构造一个XSS攻击场景，可能存在的场景很多，比如文章的评论，微博等。用户输入后，其他用户就可以看到别人的评论，微博等信息。而现在我们刻意输入一些可以执行的代码，查看运行结果。比如，通常的文章评论是用户输入评论内容，用户查看文章就可以在评论区显示评论内容。目前很多页面都采用模板渲染的形式：用真实的数据替换一些模式字符串在浏览器动态显示内容。

这种情况，页面提交评论：

```javascript
<script>location.href="https://a.d5h5.com";</script>
```

在后台就被当作文本保存，在前端页面加载时，会执行此代码跳转到指定的页面。



#### 如何防范XSS

* 不要相信用户的输入，后台程序要对用户提交的数据进行过滤，尤其是script标签内容要过滤掉
* 不允许提交富文本数据的区域，对HTML标签进行转义
* 后台使用正则表达式限制数据模式，比如用户名要做严格限制
* 不要在页面中script标签中动态设置用户提交的数据
* 不要在HTML标签属性中动态设置用户提交的数据

防范XSS也要结合Web程序设计方式，考虑清楚是否存在可能的攻击，实际的场景可能很复杂，以上几点做到能够很大程度保证系统安全，但不能因此认为就不存在问题，XSS还有很多等待我们去探索的东西。

#### CSRF

Cross-site request forgery，跨站请求伪造。这种攻击依赖于用户和网站建立的信任关系，需要用户登录后，强迫用户提交某些请求操作，比如用户登录后打开了另一个网页，但是这个页面却包含了一个指向用户已登录网站的请求，这个请求可能是转账操作，可能是删除某些记录，也可能是添加新用户给攻击者。此时用户在不知不觉中就已经中招。CSRF攻击的难度比较大，条件要求比较苛刻，但是危害很大。总结起来，CSRF的攻击条件是：

```
1. 用户登录要攻击的网站
2. 了解网站的URI结构
3. 诱导用户点击含有攻击请求的页面
```



#### CSRF实例演示

示例使用简单的页面演示原理，用户登录后显示目录中的文件，并可以删除指定文件，删除操作是通过发送请求http://wx.d5h5.com/files.php?act=deletefilename=FILENAME完成的，FILENAME是参数，具体的文件名通过构造请求传递。这是一个GET请求，如果用户不登录是不能删除的。

但是在另一个页面http://wy.d5h5.com/csrf.html，看起来就是一个介绍CSRF的简单页面，但是此页面隐含了一个img标签：

```html
<img src="http://wx.d5h5.com/files.php?act=delete&filename=vhost.conf" alt="">
```

图片肯定是不能显示的，所以alt属性起作用，设置为空，则什么也不显示，用户在页面上感知不到，但是打开此页面就已经发起了攻击。



#### 防止CSRF

* 对于要更改后台数据的操作，请求类型不要使用GET，给用户提供的操作要使用POST，在以上示例中，filename参数使用POST请求传递。每次POST请求都要附带一个token值，这个token值是后台生成并嵌入到表单中，验证token值以后才可以操作。

* 另一种方式可以是更改数据操作加上验证码，iframe标签可以做隐式POST提交，同样可以发起CSRF攻击。或者使用AJAX发起POST请求。
* 验证请求来源，但是这是可以伪造的，仅仅是增加了攻击成本，无法防止攻击。



#### XSS与CSRF

XSS与CSRF往往可以配合使用，而且单纯的使用某些手段可能难有突破，但配合起来，威力就很大，比如以上防范CSRF所使用的token，如果存在于Cookie（大部分网站都要使用Cookie）。如果存在XSS漏洞，则利用XSS可以获取token。



#### SessionID攻击

这种攻击方式在使用cookie存储后台SessionID的场景中会用到，尤其是早期站点，使用的生成SessionID算法对于开源的软件，可以从编程语言源代码中获取并找出漏洞。甚至早期的站点使用了非常不安全的方式在cookie中存储登录ID或者是其他标记信息，用户通过两次登录查看自己的登录标记，猜测出中间可能存在的登录ID值。SessionID的长度太短也可以直接被暴力破解。



#### Cookie安全

Cookie一直被诟病不安全，目前来说，还没有更好的方式能完全代替Cookie，但是Cookie的使用方式需要认真对待，目前浏览器提供的Cookie操作可以限制Cookie允许的域名，生存期限，是否允许通过JS获取，只允许HTTPS等操作可以很大程度上保证Cookie安全，尽管总有人说Storage可以代替Cookie，但是由于Stotrage是针对当前页面的，比如你打开两个页面，尽管都在同一个站点，但是Storage不共享，这对会话来说是一个大问题，另一方面，Storage并没有安全Cookie的那些限制，读取更自由。所以Storage代替Cookie目前来说是不实际的。



#### SQL注入

SQL注入就是通过把SQL语句插入到GET请求参数，或者POST表单数据，达到欺骗服务器执行恶意SQL语句的作用。

比如，站点获取资源：https://a.d.com/user/?id=1024。但是需要查询用户是否对id是1024的资源具备查询权限，如果构造的的SQL语句是：SELECT * from xxx where id=1024，可能这时候1024就不存在，那如果用户输入请求https://a.d.com/user/?id=1024 OR 1=1则SQL语句变成了：

SELECT * from xxx where id=1024 OR 1=1

此时可以获取任何数据。

#### 防止SQL注入

* 对用户输入的数据检查类型以及进行过滤以及转义。有些参数是严格限制类型的，比如id，只能是数字类型。还有一些特殊的字段只能是英文字符，获取数据要根据类型限制做检测。
* 一般数据库扩展都会提供quote（引用）操作，比如以上请求变成：SELECT * from xxx where id=’1024 OR 1=1’就无法执行。这种操作就是在后台对用户的输入加引号。当然如果用户输入1024’ OR ‘1=1仍然可以执注入，所以尽量使用扩展提供的处理函数，会在适当情况加引号并且会转义特殊字符以及适配底层驱动。
* ORM扩展会提供这些操作防止SQL注入，不过不要盲目相信扩展，扩展也是可能出问题的，另一方面ORM也有限制，有些复杂的业务场景只能使用SQL字符串拼接。



#### 第三方扩展信任危机

2018年11月，npm（NodeJS包管理）上的一个模块event-stream爆出被植入窃取比特币的后门，而这个扩展每周有大概200万的下载量，此扩展原开发者不再维护，转交给新的开发者，因此被新开发者植入后门。

在此之前，2016年3月npm也出过问题，当时一个库的开发者撤回了自己的代码，导致大量依赖于此的扩展都无法使用，包括React以及Babel都有影响。

其他编程语言的问题仍然不能轻视，使用别人的扩展永远是受制于人，而且扩展中有没有后门也不清楚，有些后门程序是使用软件工具很难检测出来的，甚至根本检测不出来。这种情况在脚本语言中经常见到，因为脚本语言动态解释的特点虽然功能强大，但是问题也多，普通文本就可以直接被拿来执行，这在编译型语言中还存在很大限制（也不是不可能，实际上，操作系统具备后门我们也不清楚），而在解释型语言中植入后门非常方便。

由此带来的信任危机值得大家思考，所谓不要重复造轮子是说给菜鸟程序员的，有能力一定要自己造轮子，你会学到更多，而且有必要的情况，可以使用自己的轮子。